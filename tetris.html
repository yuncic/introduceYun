<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>웹 테트리스</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.22.1/full/pyodide.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            touch-action: none;
        }
        #gameCanvas {
            border: 1px solid white;
            max-width: 100%;
            max-height: 100vh;
        }
        #mobileControls {
            position: absolute;
            bottom: 10px;
            display: none;
            width: 100%;
            justify-content: space-around;
        }
        .mobileButton {
            background-color: rgba(255, 255, 255, 0.3);
            border: none;
            color: white;
            padding: 15px;
            font-size: 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="gameContainer" style="position: relative;">
        <canvas id="gameCanvas"></canvas>
        <button id="exitBtn" style="position: absolute; bottom: 10px; right: 10px; display: none; padding: 10px; font-size: 16px; background-color: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">대기창으로 나가기</button>
    </div>
    <div id="mobileControls">
        <button class="mobileButton" id="leftBtn">←</button>
        <button class="mobileButton" id="rotateBtn">↻</button>
        <button class="mobileButton" id="rightBtn">→</button>
        <button class="mobileButton" id="downBtn">↓</button>
    </div>
    <script>
        async function main() {
            let pyodide = await loadPyodide();
            await pyodide.loadPackage("numpy");
            await pyodide.runPythonAsync(`
                import js
                import numpy as np
                from pyodide.ffi import create_proxy
                import random
                import json

                # 색상 정의
                BLACK = (0, 0, 0)
                WHITE = (255, 255, 255)
                COLORS = [
                    (255, 204, 204),  # 파스텔 핑크
                    (204, 255, 204),  # 파스텔 그린
                    (204, 204, 255),  # 파스텔 블루
                    (255, 255, 204),  # 파스텔 옐로우
                    (255, 204, 255),  # 파스텔 라벤더
                    (204, 255, 255),  # 파스텔 시안
                ]

                # 테트리스 블록 모양 정의
                SHAPES = [
                    [[1, 1, 1, 1]],
                    [[1, 1], [1, 1]],
                    [[1, 1, 1], [0, 1, 0]],
                    [[1, 1, 1], [1, 0, 0]],
                    [[1, 1, 1], [0, 0, 1]],
                    [[1, 1, 0], [0, 1, 1]],
                    [[0, 1, 1], [1, 1, 0]]
                ]

                # 게임 설정
                GRID_WIDTH = 10
                GRID_HEIGHT = 20
                BLOCK_SIZE = 30

                # 게임 영역 크기 계산
                GAME_WIDTH = GRID_WIDTH * BLOCK_SIZE
                GAME_HEIGHT = GRID_HEIGHT * BLOCK_SIZE

                # 전체 화면 크기 설정
                SCREEN_WIDTH = GAME_WIDTH + 200
                SCREEN_HEIGHT = GAME_HEIGHT + 60

                class Particle:
                    def __init__(self, x, y, color):
                        self.x = x
                        self.y = y
                        self.color = color
                        self.size = random.uniform(2, 5)
                        self.speed_x = random.uniform(-2, 2)
                        self.speed_y = random.uniform(-2, 2)
                        self.lifetime = random.randint(30, 60)

                    def update(self):
                        self.x += self.speed_x
                        self.y += self.speed_y
                        self.lifetime -= 1

                    def draw(self, ctx):
                        ctx.fillStyle = f'rgba({self.color[0]},{self.color[1]},{self.color[2]},{self.lifetime/60})'
                        ctx.beginPath()
                        ctx.arc(self.x, self.y, self.size, 0, 2 * np.pi)
                        ctx.fill()

                class Tetris:
                    def __init__(self):
                        self.canvas = js.document.getElementById('gameCanvas')
                        self.ctx = self.canvas.getContext('2d')
                        self.resize_canvas()
                        self.grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
                        self.current_piece = self.new_piece()
                        self.game_over = False
                        self.show_game_over = False
                        self.score = 0
                        self.combo = 0
                        self.speed_level = 1
                        self.fall_time = 0
                        self.base_fall_speed = 0.5
                        self.fast_fall = False
                        self.fast_fall_speed = 0.05
                        self.ghost_piece = None
                        self.game_started = False
                        self.update_ghost_piece()
                        self.particles = []
                        self.high_score = self.load_high_score()
                        self.exit_btn = js.document.getElementById('exitBtn')
                        self.exit_btn.style.display = 'none'

                    def resize_canvas(self):
                        global BLOCK_SIZE, GAME_WIDTH, GAME_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT
                        window_width = js.window.innerWidth
                        window_height = js.window.innerHeight
                        
                        if window_width < 500 or window_height < 700:  # 모바일 환경으로 간주
                            BLOCK_SIZE = min(window_width // (GRID_WIDTH + 2), window_height // (GRID_HEIGHT + 4))
                            js.document.getElementById('mobileControls').style.display = 'flex'
                        else:
                            BLOCK_SIZE = 30
                            js.document.getElementById('mobileControls').style.display = 'none'
                        
                        GAME_WIDTH = GRID_WIDTH * BLOCK_SIZE
                        GAME_HEIGHT = GRID_HEIGHT * BLOCK_SIZE
                        SCREEN_WIDTH = GAME_WIDTH + 8 * BLOCK_SIZE  # 오른쪽 여백을 조금 더 늘림
                        SCREEN_HEIGHT = GAME_HEIGHT + 2 * BLOCK_SIZE
                        
                        self.canvas.width = SCREEN_WIDTH
                        self.canvas.height = SCREEN_HEIGHT

                    def new_piece(self):
                        shape = random.choice(SHAPES)
                        color = random.choice(COLORS)
                        return {"shape": shape, "color": color, "x": GRID_WIDTH // 2 - len(shape[0]) // 2, "y": 0}

                    def valid_move(self, piece, x, y):
                        for i, row in enumerate(piece["shape"]):
                            for j, cell in enumerate(row):
                                if cell:
                                    if x + j < 0 or x + j >= GRID_WIDTH or y + i >= GRID_HEIGHT or (y + i >= 0 and self.grid[y + i][x + j]):
                                        return False
                        return True

                    def place_piece(self):
                        for i, row in enumerate(self.current_piece["shape"]):
                            for j, cell in enumerate(row):
                                if cell:
                                    self.grid[self.current_piece["y"] + i][self.current_piece["x"] + j] = self.current_piece["color"]
                        self.clear_lines()
                        self.current_piece = self.new_piece()
                        if not self.valid_move(self.current_piece, self.current_piece["x"], self.current_piece["y"]):
                            self.game_over = True
                            self.show_game_over = True

                    def clear_lines(self):
                        lines_cleared = 0
                        for i in range(GRID_HEIGHT):
                            if all(self.grid[i]):
                                del self.grid[i]
                                self.grid.insert(0, [0 for _ in range(GRID_WIDTH)])
                                lines_cleared += 1
                                self.create_line_clear_effect(i)
                        if lines_cleared:
                            points = lines_cleared * 10 * (self.combo + 1)
                            self.score += points
                            if self.score > self.high_score:
                                self.high_score = self.score
                                self.save_high_score()
                            self.combo += 1
                            self.update_speed_level()
                        else:
                            self.combo = 0

                    def create_line_clear_effect(self, row):
                        for _ in range(50):  # 각 줄마다 50개의 파티클 생성
                            x = random.randint(0, GAME_WIDTH)
                            y = row * BLOCK_SIZE + BLOCK_SIZE // 2
                            color = random.choice(COLORS)
                            self.particles.append(Particle(x, y, color))

                    def update_speed_level(self):
                        self.speed_level = min(10, self.score // 20 + 1)

                    def rotate_piece(self):
                        new_shape = list(zip(*self.current_piece["shape"][::-1]))
                        if self.valid_move({"shape": new_shape, "x": self.current_piece["x"], "y": self.current_piece["y"]}, self.current_piece["x"], self.current_piece["y"]):
                            self.current_piece["shape"] = new_shape
                            self.update_ghost_piece()

                    def move(self, dx, dy):
                        if self.valid_move(self.current_piece, self.current_piece["x"] + dx, self.current_piece["y"] + dy):
                            self.current_piece["x"] += dx
                            self.current_piece["y"] += dy
                            self.update_ghost_piece()
                        elif dy > 0:
                            self.place_piece()

                    def draw(self):
                        self.ctx.fillStyle = 'black'
                        self.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
                        
                        if not self.game_started:
                            self.draw_start_screen()
                        elif self.show_game_over:
                            self.draw_game_over()
                        else:
                            self.ctx.strokeStyle = 'white'
                            self.ctx.strokeRect(0, 30, GAME_WIDTH, GAME_HEIGHT)
                            
                            for i, row in enumerate(self.grid):
                                for j, cell in enumerate(row):
                                    if cell:
                                        self.ctx.fillStyle = f'rgb({cell[0]},{cell[1]},{cell[2]})'
                                        self.ctx.fillRect(j * BLOCK_SIZE + 1, i * BLOCK_SIZE + 31, BLOCK_SIZE - 2, BLOCK_SIZE - 2)
                            
                            if self.ghost_piece:
                                self.ctx.fillStyle = f'rgba({self.ghost_piece["color"][0]},{self.ghost_piece["color"][1]},{self.ghost_piece["color"][2]},0.3)'
                                for i, row in enumerate(self.ghost_piece["shape"]):
                                    for j, cell in enumerate(row):
                                        if cell:
                                            self.ctx.fillRect((self.ghost_piece["x"] + j) * BLOCK_SIZE + 1, 
                                                              (self.ghost_piece["y"] + i) * BLOCK_SIZE + 31, 
                                                              BLOCK_SIZE - 2, BLOCK_SIZE - 2)
                            
                            self.ctx.fillStyle = f'rgb({self.current_piece["color"][0]},{self.current_piece["color"][1]},{self.current_piece["color"][2]})'
                            for i, row in enumerate(self.current_piece["shape"]):
                                for j, cell in enumerate(row):
                                    if cell:
                                        self.ctx.fillRect((self.current_piece["x"] + j) * BLOCK_SIZE + 1, 
                                                          (self.current_piece["y"] + i) * BLOCK_SIZE + 31, 
                                                          BLOCK_SIZE - 2, BLOCK_SIZE - 2)
                            
                            # 파티클 그리기
                            for particle in self.particles[:]:
                                particle.update()
                                particle.draw(self.ctx)
                                if particle.lifetime <= 0:
                                    self.particles.remove(particle)

                            # 점수와 최고 점수 표시 위치 조정 및 폰트 크기 증가
                            self.ctx.fillStyle = 'white'
                            self.ctx.font = f'bold {BLOCK_SIZE*0.7}px Arial'  # 폰트 크기를 키움
                            self.ctx.fillText(f'현재 점수: {self.score}', GAME_WIDTH + BLOCK_SIZE, BLOCK_SIZE * 2)
                            self.ctx.fillText(f'최고 점수: {self.high_score}', GAME_WIDTH + BLOCK_SIZE, BLOCK_SIZE * 3.5)
                            self.ctx.fillText(f'속도: {self.speed_level}', GAME_WIDTH + BLOCK_SIZE, BLOCK_SIZE * 5)

                    def draw_start_screen(self):
                        self.ctx.fillStyle = 'black'
                        self.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
                        
                        self.ctx.fillStyle = 'white'
                        self.ctx.font = f'bold {BLOCK_SIZE * 1.5}px Arial'
                        self.ctx.textAlign = 'center'
                        self.ctx.fillText('테트리스', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - BLOCK_SIZE * 3)
                        
                        # 최고 점수 표시
                        self.ctx.font = f'{BLOCK_SIZE * 0.7}px Arial'
                        self.ctx.fillText(f'최고 점수: {self.high_score}', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - BLOCK_SIZE)
                        
                        self.ctx.fillStyle = 'green'
                        self.ctx.fillRect(SCREEN_WIDTH // 2 - BLOCK_SIZE * 3, SCREEN_HEIGHT // 2, BLOCK_SIZE * 6, BLOCK_SIZE * 1.5)
                        self.ctx.fillStyle = 'white'
                        self.ctx.font = f'bold {BLOCK_SIZE * 0.7}px Arial'
                        self.ctx.fillText('게임 시작', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + BLOCK_SIZE * 0.8)
                        
                        self.exit_btn.style.display = 'none'
                        self.ctx.textAlign = 'left'  # 텍스트 정렬을 다시 왼쪽으로 설정

                    def draw_game_over(self):
                        self.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'
                        self.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
                        
                        self.ctx.fillStyle = 'white'
                        self.ctx.font = f'bold {BLOCK_SIZE}px Arial'
                        self.ctx.textAlign = 'center'
                        self.ctx.fillText('게임 오버', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - BLOCK_SIZE * 2)
                        
                        self.ctx.font = f'{BLOCK_SIZE * 0.7}px Arial'
                        self.ctx.fillText(f'현재 점수: {self.score}', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
                        self.ctx.fillText(f'최고 점수: {self.high_score}', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + BLOCK_SIZE)
                        
                        self.ctx.fillStyle = 'green'
                        self.ctx.fillRect(SCREEN_WIDTH // 2 - BLOCK_SIZE * 3, SCREEN_HEIGHT // 2 + BLOCK_SIZE * 2, BLOCK_SIZE * 6, BLOCK_SIZE * 1.5)
                        self.ctx.fillStyle = 'white'
                        self.ctx.font = f'{BLOCK_SIZE * 0.7}px Arial'
                        self.ctx.fillText('다시 시작', SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + BLOCK_SIZE * 2.8)
                        
                        self.exit_btn.style.display = 'block'
                        self.ctx.textAlign = 'left'  # 텍스트 정렬을 다시 왼쪽으로 설정

                    def update(self, dt):
                        self.fall_time += dt
                        if not self.game_over:
                            self.update_ghost_piece()
                            current_fall_speed = self.fast_fall_speed if self.fast_fall else (self.base_fall_speed - (self.speed_level - 1) * 0.05)
                            if self.fall_time > current_fall_speed:
                                self.move(0, 1)
                                self.fall_time = 0

                    def update_ghost_piece(self):
                        self.ghost_piece = {
                            "shape": self.current_piece["shape"],
                            "color": self.current_piece["color"],
                            "x": self.current_piece["x"],
                            "y": self.current_piece["y"]
                        }
                        while self.valid_move(self.ghost_piece, self.ghost_piece["x"], self.ghost_piece["y"] + 1):
                            self.ghost_piece["y"] += 1

                    def start_game(self):
                        self.game_started = True
                        self.game_over = False
                        self.show_game_over = False
                        self.score = 0
                        self.combo = 0
                        self.speed_level = 1
                        self.grid = [[0 for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]
                        self.current_piece = self.new_piece()
                        self.update_ghost_piece()
                        self.exit_btn.style.display = 'block'

                    def reset_game(self):
                        self.__init__()
                        self.game_started = False
                        self.exit_btn.style.display = 'none'

                    def load_high_score(self):
                        try:
                            return int(js.localStorage.getItem('tetris_high_score') or 0)
                        except:
                            return 0

                    def save_high_score(self):
                        js.localStorage.setItem('tetris_high_score', str(self.high_score))

                game = Tetris()

                def game_loop(time):
                    game.update(1/60)  # Assuming 60 FPS
                    game.draw()
                    js.requestAnimationFrame(create_proxy(game_loop))

                def handle_keydown(event):
                    if game.game_started and not game.game_over:
                        if event.key == 'ArrowLeft':
                            game.move(-1, 0)
                        elif event.key == 'ArrowRight':
                            game.move(1, 0)
                        elif event.key == 'ArrowDown':
                            game.fast_fall = True
                        elif event.key == ' ':
                            game.rotate_piece()

                def handle_keyup(event):
                    if event.key == 'ArrowDown':
                        game.fast_fall = False

                def handle_click(event):
                    if not game.game_started:
                        if SCREEN_WIDTH // 2 - BLOCK_SIZE * 3 < event.offsetX < SCREEN_WIDTH // 2 + BLOCK_SIZE * 3 and SCREEN_HEIGHT // 2 < event.offsetY < SCREEN_HEIGHT // 2 + BLOCK_SIZE * 1.5:
                            game.start_game()
                    elif game.show_game_over:
                        if SCREEN_WIDTH // 2 - BLOCK_SIZE * 3 < event.offsetX < SCREEN_WIDTH // 2 + BLOCK_SIZE * 3 and SCREEN_HEIGHT // 2 + BLOCK_SIZE * 2 < event.offsetY < SCREEN_HEIGHT // 2 + BLOCK_SIZE * 3.5:
                            game.reset_game()
                            game.start_game()

                def handle_resize(event):
                    game.resize_canvas()

                def handle_mobile_control(event):
                    button_id = event.target.id
                    if button_id == 'leftBtn':
                        game.move(-1, 0)
                    elif button_id == 'rightBtn':
                        game.move(1, 0)
                    elif button_id == 'downBtn':
                        game.fast_fall = True
                    elif button_id == 'rotateBtn':
                        game.rotate_piece()

                def handle_exit(event):
                    game.reset_game()

                js.document.addEventListener('keydown', create_proxy(handle_keydown))
                js.document.addEventListener('keyup', create_proxy(handle_keyup))
                js.document.getElementById('gameCanvas').addEventListener('click', create_proxy(handle_click))
                js.window.addEventListener('resize', create_proxy(handle_resize))
                js.document.getElementById('mobileControls').addEventListener('touchstart', create_proxy(handle_mobile_control))
                js.document.getElementById('mobileControls').addEventListener('touchend', create_proxy(lambda event: setattr(game, 'fast_fall', False)))
                js.document.getElementById('exitBtn').addEventListener('click', create_proxy(handle_exit))

                # 터치 이벤트 방지
                js.document.body.addEventListener('touchmove', create_proxy(lambda event: event.preventDefault()), {'passive': False})

                js.requestAnimationFrame(create_proxy(game_loop))
            `)
        }
        main();
    </script>
</body>
</html>